If you would like to see the reports I made, they are in the folder Documentation. They include compilation and individual reports. If you wish to see the programs that went with the other reports they are on my GitHub as cs300+’data structure.’

What was the problem you were solving in the projects for this course?
    - The goal of this project was to evaluate and compare the runtime complexity of different data structures and their associated algorithms. The primary objective was to determine which data structure — Binary Search Tree (BST), HashTable, or LinkedList — was most suitable for a specific use case by analyzing each one's worst-case time complexity (Big O notation).

How did you approach the problem?
    - To approach this problem, I focused on understanding and calculating the Big O complexity for each of the three data structures: BST, HashTable, and LinkedList. I applied deductive reasoning by aligning theoretical time complexities with empirical runtime data from program executions. This helped me determine that BSTs offered the most efficient performance for the given use case. This process emphasized how critical it is to choose the right data structure, as it directly affects algorithm efficiency and overall software performance.

How did you overcome any roadblocks?
    - One of the main challenges was performing accurate runtime analysis, an area where I initially lacked experience. Interpreting performance metrics and linking them back to Big O notation required practice and patience. Another difficulty was ensuring consistency across implementations — adapting a single pseudocode logic across different structures (like HashTables and LinkedLists) wasn’t always straightforward. Personally, I find flowcharts more intuitive, as they allow more flexibility in design compared to rigid pseudocode, which made transitioning between structures a bit tricky.

How has your work on this project expanded your approach to designing software and developing programs?
    - This project helped solidify the idea that data structure choice is just as crucial as algorithm design. Picking an inefficient combination can significantly affect performance, especially at scale. I now have a deeper appreciation for how data structures and algorithms are interdependent, and how important it is to match the right tools to the right problem.

How has your work evolved the way you write maintainable, readable, and adaptable code?
    - Working through this project reaffirmed my appreciation for UML diagrams and the planning stages of the Software Development Life Cycle (SDLC). As I progress through this program, I increasingly recognize that maintainable and adaptable software starts with thoughtful design. Mapping out structure and logic early helps ensure that code remains organized and easier to modify or scale later on.

